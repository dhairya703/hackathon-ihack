from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from fastapi.responses import JSONResponse
import requests
import json
import xml.etree.ElementTree as ET
import re
from fastapi.responses import JSONResponse
import os
import json
from fastapi import APIRouter, HTTPException
app = FastAPI()
from dotenv import load_dotenv
load_dotenv()

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GEMINI_URL = os.getenv("GEMINI_URL")
# 📦 Pydantic Model for Input
class NmapData(BaseModel):
    data: dict

# 🔍 Call Gemini API
def call_gemini(prompt: str) -> str:
    headers = {"Content-Type": "application/json"}
    payload = {
        "contents": [{"parts": [{"text": prompt}]}]
    }
    response = requests.post(
        f"{GEMINI_URL}?key={GEMINI_API_KEY}",
        headers=headers,
        json=payload
    )
    try:
        return response.json()["candidates"][0]["content"]["parts"][0]["text"].strip()
    except Exception as e:
        return f"[Gemini error] {str(e)}"

# 🧠 Prompt Generator
def generate_vuln_patch_prompt(nmap_json: dict) -> str:
    prompt = f"""
You are a cybersecurity assistant. The following is the output of an Nmap scan showing detected services, OS, and versions.

Your task is to:
1. Identify any **known critical vulnerabilities (CVEs)** for the listed software/services.
2. For each service, return:
    - Service Name
    - Port
    - Detected Version
    - List of relevant CVEs (if any)
    - description of the service
    - CVSS Score (for each CVE)
    - Risk Level (Critical,High, Medium, Low)
    - Recommended patch or remediation steps 

Return the result in a structured **JSON** format like this:

[
  {{
    "type": "cve",
    "id": "CVE-2024-47252",
    "is_exploit": false,
    "cvss": 7.5,
    "severity": "HIGH",
    "description": "this contains this problem.",
    "remediation": "Sanitize user-supplied data in mod_ssl before logging how can we solve this",
    "link": "https://nvd.nist.gov/vuln/detail/CVE-2024-47252"
  }}
]

Here is the JSON input data from the Nmap scan:

{json.dumps(nmap_json, indent=2)}

Only respond with the JSON output, no explanation.
"""
    return prompt

# 🔧 Fix malformed vulners line
def fix_invalid_vulners_line(content: str) -> str:
    return re.sub(r'<script id="vulners"\s*=\s*', '<script id="vulners" output=', content)

# 📄 Parse Nmap XML
def parse_nmap_xml_to_json(filepath="data/vuln_scan2.xml"):
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            raw_content = f.read()
        fixed_content = fix_invalid_vulners_line(raw_content)
        root = ET.fromstring(fixed_content)
    except ET.ParseError as e:
        return {"error": f"XML parsing failed: {str(e)}"}
    except FileNotFoundError:
        return {"error": f"File not found: {filepath}"}

    result = {
        "os": set(),
        "services": [],
        "user_agents": set()
    }

    for host in root.findall(".//host"):
        for port in host.findall(".//port"):
            protocol = port.attrib.get("protocol")
            portid = port.attrib.get("portid")

            service_tag = port.find("service")
            if service_tag is not None:
                service_info = {
                    "port": portid,
                    "protocol": protocol,
                    "name": service_tag.attrib.get("name"),
                    "product": service_tag.attrib.get("product"),
                    "version": service_tag.attrib.get("version"),
                    "extrainfo": service_tag.attrib.get("extrainfo"),
                    "ostype": service_tag.attrib.get("ostype"),
                    "cpe": service_tag.findtext("cpe")
                }
                result["services"].append(service_info)
                if service_info["ostype"]:
                    result["os"].add(service_info["ostype"])

            for script in port.findall("script"):
                if script.attrib.get("id") == "http-server-header":
                    for elem in script.findall("elem"):
                        if elem.text:
                            result["user_agents"].add(elem.text)

    result["os"] = list(result["os"])
    result["user_agents"] = list(result["user_agents"])

    return result

# 🚀 Analyze via API Input
@app.post("/analyze")
def analyze_vulnerabilities(nmap_input: NmapData):
    try:
        prompt = generate_vuln_patch_prompt(nmap_input.data)
        result = call_gemini(prompt)
        return {"analysis": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# 📂 Analyze from File
@app.post("/analyze/fromfile")
def analyze_from_file():
    try:
        json_result = parse_nmap_xml_to_json("data/vuln_scan2.xml")
        with open("data/map.json", "w", encoding="utf-8") as f:
            json.dump(json_result, f, indent=2)

        nmap_obj = NmapData(data=json_result)
        prompt = generate_vuln_patch_prompt(nmap_obj.data)
        result = call_gemini(prompt)
        print(result)

        cleaned = re.sub(r"^```json\s*|\s*```$", "", result.strip(), flags=re.DOTALL)

        with open("data/result2.json", "w", encoding="utf-8") as out_file:
            json.dump(json.loads(cleaned), out_file, indent=2)

        return JSONResponse(content={"message": "Analysis saved to result2.json", "analysis": cleaned})

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/analyze/map")
def get_map_json():
    filepath = "data/map.json"
    if not os.path.exists(filepath):
        raise HTTPException(status_code=404, detail="map.json not found")
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    return JSONResponse(content=data)

@app.get("/analyze/result1")
def get_res_json():
    filepath = "data/result.json"
    if not os.path.exists(filepath):
        raise HTTPException(status_code=404, detail="result.json not found")
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    return JSONResponse(content=data)
@app.get("/analyze/result2")
def get_res2_json():
    filepath = "data/result2.json"
    if not os.path.exists(filepath):
        raise HTTPException(status_code=404, detail="result2.json not found")
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    return JSONResponse(content=data)

@app.get("/analyze/vulnerabilitesjson")
def get_vulnerabilitesjson_json():
    filepath = "data/vuln_scan2.json"
    if not os.path.exists(filepath):
        raise HTTPException(status_code=404, detail="vulnerability.json not generated")
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    return JSONResponse(content=data)

@app.get("/analyze/vulnerabilitesxml")
def get_vulnerabilitesxml_json():
    filepath = "data/vuln_scan2.xml"
    if not os.path.exists(filepath):
        raise HTTPException(status_code=404, detail="vuln_scan2.xml not found")
    with open(filepath, "r", encoding="utf-8") as f:
        data = json.load(f)
    return JSONResponse(content=data)